from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.keys import Keys
import os
import keyboard
import time

# Configuración
chrome_options = webdriver.ChromeOptions()
prefs = {
    "download.default_directory": os.path.join(os.path.expanduser("~"), "Desktop"),
    "download.prompt_for_download": False,
    "download.directory_upgrade": True,
    "safebrowsing.enabled": True
}
chrome_options.add_experimental_option("prefs", prefs)

# Al iniciar el driver:
# driver = webdriver.Chrome(options=chrome_options)

chrome_path = r"C:\Temp\chromedriver\chromedriver.exe"  # ¡Asegúrate de que el archivo EXE existe aquí!
url = "http://180.176.105.244/"
usuario = "C356882"
password = "derekNatalie72"
PASSWORD_WINDOW = 'F3nix@202503d'

def export_to_csv(driver):
    try:
        # 1. Esperar a que aparezca la columna "Número efectivo"
        columna_numero = WebDriverWait(driver, 20).until(
            EC.presence_of_element_located((By.CSS_SELECTOR, "th[name='task_effective_number']"))
        )
        
        # 2. Realizar click derecho sobre la columna
        action = ActionChains(driver)
        action.context_click(columna_numero).perform()
        time.sleep(1)  # Esperar a que aparezca el menú contextual
        
        # 3. Seleccionar opción "Exportar"
        exportar_option = WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.CSS_SELECTOR, "div[data-context-menu-label='Exportar']")))
        exportar_option.click()
        time.sleep(1)  # Esperar a que aparezca el submenú
        
        # 4. Seleccionar formato CSV
        csv_option = WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.XPATH, "//div[@class='context_item' and text()='CSV']")))
        csv_option.click()
        
        # 5. Esperar a que aparezca el diálogo de guardado (manejo dependiente del sistema)
        time.sleep(3)  # Tiempo para que aparezca el diálogo
        
        # 6. Guardar el archivo (requiere configuración previa del navegador o AutoIt)
        # Opción A: Configuración previa de Chrome para descargas
        # Opción B: Usar PyWinAuto para manejar el diálogo de guardado
        
        print("Exportación a CSV iniciada. El archivo se guardará como 'Incident.csv' en el Escritorio.")
        return True
        
    except Exception as e:
        print(f"Error durante la exportación: {str(e)}")
        driver.save_screenshot("export_error.png")
        return False

def handle_microsoft_auth(driver):
    try:
        # Cambiar al último tab abierto (la ventana emergente)
        driver.switch_to.window(driver.window_handles[-1])
        
        # Esperar y llenar el campo de contraseña
        password_field = WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.ID, "i0118"))
        )
        password_field.send_keys(PASSWORD_WINDOW)
        password_field.send_keys(Keys.RETURN)
        
        # Esperar por la opción de autenticación alternativa
        auth_alternative = WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.XPATH, "//a[contains(text(), 'No puedo usar mi aplicación Microsoft Authenticator')]"))
        )
        auth_alternative.click()
        
        # Esperar y seleccionar la opción de llamada telefónica
        call_option = WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.XPATH, "//div[contains(text(), 'Llamar al +XX XXXXXXXX32')]")))
        call_option.click()
        
        print("Esperando 10 segundos para que contesten la llamada...")
        time.sleep(10)
        
        # Volver al tab principal
        driver.switch_to.window(driver.window_handles[0])
        return True
        
    except Exception as e:
        print(f"Error en autenticación: {str(e)}")
        return False


try:
    # Iniciar Chrome
    service = Service(chrome_path)
    driver = webdriver.Chrome(service=service)
    driver.maximize_window()
    driver.get(url)

    # 1. Click en botón "SDK-CAU Reportes"
    btn_reportes = WebDriverWait(driver, 10).until(
        EC.element_to_be_clickable((By.XPATH, "//button[contains(@class, 'btn-primary') and contains(., 'SDK-CAU Reportes')]"))
    )
    btn_reportes.click()

    # 2. Ingresar credenciales
    WebDriverWait(driver, 10).until(
        EC.presence_of_element_located((By.ID, "usr"))
    )
    
    input_usuario = driver.find_element(By.ID, "usr")
    input_password = driver.find_element(By.ID, "pass")

    input_usuario.send_keys(usuario)
    input_password.send_keys(password + Keys.RETURN)

    # 3. Esperar preloader
    WebDriverWait(driver, 30).until(
        EC.presence_of_element_located((By.XPATH, "//div[@id='preloader' and contains(@class, 'preloader-close')]"))
    )
    
    # 4. Click en "Actualizar Data"
    link_actualizar = WebDriverWait(driver, 10).until(
        EC.element_to_be_clickable((By.XPATH, "//a[@href='../apps/dataupdate.html']")))
    link_actualizar.click()

    # 5. Click en el ícono de bi-bandaid-fill
    icono_bandaid = WebDriverWait(driver, 10).until(
        EC.element_to_be_clickable((By.XPATH, "//i[contains(@class, 'bi-bandaid-fill')]")))
    icono_bandaid.click()

    time.sleep(3)
    keyboard.press_and_release('alt+a')  # Algunos sistemas usan Alt+S
    time.sleep(1)
    keyboard.press_and_release('enter')

    success = handle_microsoft_auth(driver)
    if not success:
        print("Falló el proceso de autenticación")
    time.sleep(50)
    
    success = export_to_csv(driver)
    if not success:
        print("Falló el proceso de Guardado")



    print("Proceso completado exitosamente")
    time.sleep(150)

except Exception as e:
    print(f"Error: {str(e)}")
    if 'driver' in locals():  # Si el driver se creó pero hubo un error después
        driver.save_screenshot("error.png")  # Guarda captura del error
finally:
    if 'driver' in locals():
        driver.quit()
